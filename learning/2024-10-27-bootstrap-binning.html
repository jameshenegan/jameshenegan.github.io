<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>

<style>
body {
  font-family: "Avenir Next", Helvetica, Arial, sans-serif;
  padding: 1em;
  margin: auto;
  max-width: 42em;
  background: #fefefe;
}

h1,
h2,
h3,
h4,
h5,
h6 {
  font-weight: bold;
}

h1 {
  color: #000000;
  font-size: 28pt;
}

h2 {
  border-bottom: 1px solid #cccccc;
  color: #000000;
  font-size: 24px;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777777;
  background-color: inherit;
  font-size: 14px;
}

hr {
  height: 0.2em;
  border: 0;
  color: #cccccc;
  background-color: #cccccc;
}

p,
blockquote,
ul,
ol,
dl,
li,
table,
pre {
  margin: 15px 0;
}

img {
  max-width: 100%;
}

table {
  border-collapse: collapse;
  width: 100%;
}

table,
th,
td {
  border: 1px solid #eaeaea;

  border-radius: 3px;
  padding: 5px;
}

tr:nth-child(even) {
  background-color: #f8f8f8;
}

a,
a:visited {
  color: #4183c4;
  background-color: inherit;
  text-decoration: none;
}

#message {
  border-radius: 6px;
  border: 1px solid #ccc;
  display: block;
  width: 100%;
  height: 60px;
  margin: 6px 0px;
}

button,
#ws {
  font-size: 10pt;
  padding: 4px 6px;
  border-radius: 5px;
  border: 1px solid #bbb;
  background-color: #eee;
}

code,
pre,
#ws,
#message {
  font-family: Monaco, monospace;
  font-size: 10pt;
  border-radius: 3px;
  background-color: #f8f8f8;
  color: inherit;
}

code {
  border: 1px solid #eaeaea;
  margin: 0 2px;
  padding: 0 5px;
}

pre {
  border: 1px solid #cccccc;
  overflow: auto;
  padding: 4px 8px;
}

pre > code {
  border: 0;
  margin: 0;
  padding: 0;
}

#ws {
  background-color: #f8f8f8;
}

.send {
  color: #77bb77;
}
.server {
  color: #7799bb;
}
.error {
  color: #aa0000;
}
</style>


     </head>
  <body><h3
id="detailed-tutorial-bootstrapped-binning-and-plotting-of-a-continuous-variable-against-a-target">Detailed
Tutorial: Bootstrapped Binning and Plotting of a Continuous Variable
Against a Target</h3>
<p>In this tutorial, we will walk through a Python function designed to
explore the relationship between a continuous variable and a binary
target variable using <strong>bootstrapping</strong> and <strong>binned
averages</strong>. We’ll explain each part of the function, showing how
it works step by step. The final goal is to plot the mean of the target
variable for different ranges (buckets) of the continuous variable, with
uncertainty illustrated by plotting the results of multiple bootstrap
samples.</p>
<hr />
<h3 id="function-overview">1. Function Overview</h3>
<p>The function
<code>plot_binned_bootstrap_full_gray_original_scale</code> takes a
dataset and:</p>
<ol type="1">
<li><strong>Bootstraps the dataset</strong> to resample it many
times.</li>
<li><strong>Divides</strong> (bins) the continuous variable into buckets
(by default into deciles, i.e., 10 groups).</li>
<li><strong>Calculates</strong> the mean of the target variable for each
bucket in every bootstrap sample.</li>
<li><strong>Plots</strong> each bootstrap sample’s result as a light
gray line to show variability.</li>
<li><strong>Overlays</strong> the average relationship from the
bootstraps in blue.</li>
</ol>
<p>This helps to visualize not only the overall trend but also the
uncertainty inherent in the estimates due to the limited sample
size.</p>
<hr />
<h3 id="importing-required-libraries">2. Importing Required
Libraries</h3>
<p>Before we dive into the function, the following libraries are
necessary:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np       <span class="co"># For numerical operations</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd      <span class="co"># For data manipulation</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt   <span class="co"># For plotting</span></span></code></pre></div>
<hr />
<h3 id="function-parameters">3. Function Parameters</h3>
<p>Here’s the core of the function, starting with its parameters:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_binned_bootstrap_full_gray_original_scale(df, continuous_col, target_col, n_buckets<span class="op">=</span><span class="dv">10</span>, n_bootstrap<span class="op">=</span><span class="dv">1000</span>):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Plots the relationship between a continuous column and the mean of a target column,</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co">    binned into a specified number of buckets with bootstrapped uncertainty shown as individual light gray lines.</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co">    The x-axis reflects the original scale of the continuous variable.</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co">    - df: pandas DataFrame containing the data.</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="co">    - continuous_col: string, the name of the continuous column.</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="co">    - target_col: string, the name of the target column.</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="co">    - n_buckets: int, the number of buckets (default is 10 for deciles).</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="co">    - n_bootstrap: int, number of bootstrap samples to use.</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span></code></pre></div>
<ul>
<li><strong><code>df</code></strong>: The DataFrame containing your
data.</li>
<li><strong><code>continuous_col</code></strong>: The column name of the
continuous variable (e.g., age, income).</li>
<li><strong><code>target_col</code></strong>: The column name of the
target variable (e.g., binary classification like 1/0).</li>
<li><strong><code>n_buckets</code></strong>: How many groups (bins) you
want to divide the continuous variable into (default: 10 deciles).</li>
<li><strong><code>n_bootstrap</code></strong>: The number of bootstrap
resamples to perform (default: 1000).</li>
</ul>
<hr />
<h3 id="setting-up-data-structures">4. Setting Up Data Structures</h3>
<p>Next, we prepare to store the results of each bootstrap
iteration:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Store the means for each bucket across bootstrap samples</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>bootstrap_means <span class="op">=</span> {i: [] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_buckets)}</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>bucket_midpoints <span class="op">=</span> []</span></code></pre></div>
<ul>
<li><strong><code>bootstrap_means</code></strong>: This dictionary will
store the mean target values for each bucket, across multiple bootstrap
samples.</li>
<li><strong><code>bucket_midpoints</code></strong>: We will later
calculate the midpoints of the buckets on the original continuous scale
for plotting.</li>
</ul>
<hr />
<h3 id="bootstrap-process-and-binning">5. Bootstrap Process and
Binning</h3>
<p>The core of the function lies in this loop:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 1. Bootstrap the entire process</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n_bootstrap):</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Resample the entire dataframe with replacement</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    df_resample <span class="op">=</span> df.sample(frac<span class="op">=</span><span class="dv">1</span>, replace<span class="op">=</span><span class="va">True</span>)</span></code></pre></div>
<ul>
<li><strong>Bootstrapping</strong>: We create a new sample of the
dataset, with replacement, in each iteration of the loop. This resampled
data allows us to simulate the variability inherent in a dataset of
limited size.</li>
</ul>
<p>Next, we bin the continuous variable into <code>n_buckets</code>
(deciles, by default):</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Bin the continuous column using qcut on the resampled data</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    df_resample[<span class="st">&#39;bucket&#39;</span>], bins <span class="op">=</span> pd.qcut(df_resample[continuous_col], q<span class="op">=</span>n_buckets, duplicates<span class="op">=</span><span class="st">&#39;drop&#39;</span>, retbins<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate the midpoints of the bins (to use on the x-axis)</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    bucket_midpoints <span class="op">=</span> [(bins[i] <span class="op">+</span> bins[i<span class="op">+</span><span class="dv">1</span>]) <span class="op">/</span> <span class="dv">2</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(bins) <span class="op">-</span> <span class="dv">1</span>)]</span></code></pre></div>
<ul>
<li><strong><code>pd.qcut</code></strong>: This function divides the
continuous variable into equal-sized buckets. If the data contains
duplicate values, <code>qcut</code> handles them gracefully by avoiding
duplicate buckets using <code>duplicates='drop'</code>.</li>
<li><strong><code>retbins=True</code></strong>: This option returns the
bin edges, allowing us to compute the <strong>midpoints</strong> of each
bin for plotting purposes.</li>
</ul>
<hr />
<h3 id="calculate-bucket-means">6. Calculate Bucket Means</h3>
<p>For each bucket, we compute the mean of the target variable within
the resampled data:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate the mean for each bucket in this bootstrap sample</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, bucket <span class="kw">in</span> <span class="bu">enumerate</span>(df_resample[<span class="st">&#39;bucket&#39;</span>].unique().sort_values()):</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    bucket_data <span class="op">=</span> df_resample[df_resample[<span class="st">&#39;bucket&#39;</span>] <span class="op">==</span> bucket]</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    mean_target <span class="op">=</span> bucket_data[target_col].mean()</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    bootstrap_means[i].append(mean_target)</span></code></pre></div>
<ul>
<li><strong>Mean Calculation</strong>: We extract the data points in
each bucket and compute the mean of the target variable (e.g., how many
1’s or 0’s are in each bucket).</li>
</ul>
<hr />
<h3 id="handling-errors-in-binning">7. Handling Errors in Binning</h3>
<p>Occasionally, due to peculiarities in the data (like insufficient
unique values), <code>qcut</code> might fail to divide the data
properly. We handle this gracefully with a <code>try-except</code>
block:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">ValueError</span>:</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># If there&#39;s a problem with qcut (e.g., not enough unique values for the number of buckets), skip this sample</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">continue</span></span></code></pre></div>
<ul>
<li><strong>Error Handling</strong>: If <code>qcut</code> fails, we
simply skip that bootstrap sample and move on to the next one.</li>
</ul>
<hr />
<h3 id="plotting-the-results">8. Plotting the Results</h3>
<p>Once all bootstrap samples are processed, we plot the results:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 2. Plot each bootstrap sample in light gray</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Check if we have enough data in bootstrap_means to plot</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>valid_bootstrap_samples <span class="op">=</span> <span class="bu">min</span>([<span class="bu">len</span>(bootstrap_means[i]) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_buckets)])</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> valid_bootstrap_samples <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(valid_bootstrap_samples):</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>        means <span class="op">=</span> [bootstrap_means[j][i] <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n_buckets)]</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>        plt.plot(bucket_midpoints, means, color<span class="op">=</span><span class="st">&#39;lightgray&#39;</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span></code></pre></div>
<ul>
<li><strong>Plotting the Bootstrap Samples</strong>: For each bootstrap
iteration, we plot the means of the target variable for each bucket as a
light gray line. This gives a visual sense of the variability in the
target means across different resamples of the data.</li>
<li><strong>Midpoints on the x-axis</strong>: We use the calculated
bucket midpoints to plot the mean of the target variable on the
<strong>original scale</strong> of the continuous variable.</li>
</ul>
<hr />
<h3 id="overlaying-the-mean-relationship">9. Overlaying the Mean
Relationship</h3>
<p>To help identify the central tendency, we compute the mean across all
bootstrap samples and overlay it as a blue line:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 3. Overlay the mean across all bootstrap samples for each bucket in blue</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>mean_values <span class="op">=</span> [np.mean(bootstrap_means[i]) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_buckets)]</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>plt.plot(bucket_midpoints, mean_values, color<span class="op">=</span><span class="st">&#39;blue&#39;</span>, marker<span class="op">=</span><span class="st">&#39;o&#39;</span>, label<span class="op">=</span><span class="st">&#39;Mean of Bootstraps&#39;</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span></code></pre></div>
<ul>
<li><strong>Mean Line</strong>: This blue line shows the overall trend
based on the bootstrapped data.</li>
</ul>
<hr />
<h3 id="finishing-the-plot">10. Finishing the Plot</h3>
<p>Finally, we add labels, a title, and a legend to the plot for
clarity:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Add labels and title</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="ss">f&quot;</span><span class="sc">{</span>continuous_col<span class="sc">}</span><span class="ss"> (Original Scale)&quot;</span>)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="ss">f&quot;Mean of </span><span class="sc">{</span>target_col<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="ss">f&quot;Bootstrapped Mean of </span><span class="sc">{</span>target_col<span class="sc">}</span><span class="ss"> by </span><span class="sc">{</span>continuous_col<span class="sc">}</span><span class="ss"> Buckets&quot;</span>)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div>
<hr />
<h3 id="full-code-summary">11. Full Code Summary</h3>
<p>Here’s the complete function:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_binned_bootstrap_full_gray_original_scale(df, continuous_col, target_col, n_buckets<span class="op">=</span><span class="dv">10</span>, n_bootstrap<span class="op">=</span><span class="dv">1000</span>):</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    bootstrap_means <span class="op">=</span> {i: [] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_buckets)}</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    bucket_midpoints <span class="op">=</span> []</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n_bootstrap):</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>        df_resample <span class="op">=</span> df.sample(frac<span class="op">=</span><span class="dv">1</span>, replace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>            df_resample[<span class="st">&#39;bucket&#39;</span>], bins <span class="op">=</span> pd.qcut(df_resample[continuous_col], q<span class="op">=</span>n_buckets, duplicates<span class="op">=</span><span class="st">&#39;drop&#39;</span>, retbins<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>            bucket_midpoints <span class="op">=</span> [(bins[i] <span class="op">+</span> bins[i<span class="op">+</span><span class="dv">1</span>]) <span class="op">/</span> <span class="dv">2</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(bins) <span class="op">-</span> <span class="dv">1</span>)]</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> i, bucket <span class="kw">in</span> <span class="bu">enumerate</span>(df_resample[<span class="st">&#39;bucket&#39;</span>].unique().sort_values()):</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>                bucket_data <span class="op">=</span> df_resample[df_resample[<span class="st">&#39;bucket&#39;</span>] <span class="op">==</span> bucket]</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>                mean_target <span class="op">=</span> bucket_data[target_col].mean()</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>                bootstrap_means[i].append(mean_target)</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> <span class="pp">ValueError</span>:</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>    plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>    valid_bootstrap_samples <span class="op">=</span> <span class="bu">min</span>([<span class="bu">len</span>(bootstrap_means[i]) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_buckets)])</span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> valid_bootstrap_samples <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span></span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>(valid_bootstrap_samples):</span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a>            means <span class="op">=</span> [bootstrap_means[j][i] <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n_buckets)]</span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a>            plt.plot(bucket_midpoints, means, color<span class="op">=</span><span class="st">&#39;lightgray&#39;</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a>        mean_values <span class="op">=</span> [np.mean(bootstrap_means[i]) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_buckets)]</span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a>        plt.plot(bucket_midpoints, mean_values, color<span class="op">=</span><span class="st">&#39;blue&#39;</span>, marker<span class="op">=</span><span class="st">&#39;o&#39;</span>, label<span class="op">=</span><span class="st">&#39;Mean of Bootstraps&#39;</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true" tabindex="-1"></a>        plt.xlabel(<span class="ss">f&quot;</span><span class="sc">{</span>continuous_col<span class="sc">}</span><span class="ss"> (Original Scale)&quot;</span>)</span>
<span id="cb11-38"><a href="#cb11-38" aria-hidden="true" tabindex="-1"></a>        plt.ylabel(<span class="ss">f&quot;Mean of </span><span class="sc">{</span>target_col<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb11-39"><a href="#cb11-39" aria-hidden="true" tabindex="-1"></a>        plt.title(<span class="ss">f&quot;Bootstrapped Mean of </span><span class="sc">{</span>target_col<span class="sc">}</span><span class="ss"> by </span><span class="sc">{</span>continuous_col<span class="sc">}</span><span class="ss"> Buckets&quot;</span>)</span>
<span id="cb11-40"><a href="#cb11-40" aria-hidden="true" tabindex="-1"></a>        plt.grid(<span class="va">True</span>)</span>
<span id="cb11-41"><a href="#cb11-41" aria-hidden="true" tabindex="-1"></a>        plt.legend()</span>
<span id="cb11-42"><a href="#cb11-42" aria-hidden="true" tabindex="-1"></a>        plt.show()</span>
<span id="cb11-43"><a href="#cb11-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb11-44"><a href="#cb11-44" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">&quot;Not enough valid bootstrap samples to plot.&quot;</span>)</span></code></pre></div>
<hr />
<h3 id="conclusion">12. Conclusion</h3>
<p>This function is a powerful tool for exploring the relationship
between a continuous variable and a binary target variable. By using
bootstrapping and binning, we can visualize both the central trend and
the variability in the data, providing a more complete picture of the
relationship than simply looking at a single regression line or a
non-bootstrapped plot.</p>
<h1 id="with-percentiles">With Percentiles</h1>
<div class="sourceCode" id="cb12"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_binned_bootstrap_full_gray_with_percentiles(df, continuous_col, target_col, n_buckets<span class="op">=</span><span class="dv">10</span>, n_bootstrap<span class="op">=</span><span class="dv">1000</span>):</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="co">    Plots the relationship between a continuous column and the mean of a target column,</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="co">    binned into a specified number of buckets with bootstrapped uncertainty shown as individual light gray lines.</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="co">    The x-axis reflects the original scale of the continuous variable.</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a><span class="co">    - df: pandas DataFrame containing the data.</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a><span class="co">    - continuous_col: string, the name of the continuous column.</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a><span class="co">    - target_col: string, the name of the target column.</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a><span class="co">    - n_buckets: int, the number of buckets (default is 10 for deciles).</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a><span class="co">    - n_bootstrap: int, number of bootstrap samples to use.</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Store the means for each bucket across bootstrap samples</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>    bootstrap_means <span class="op">=</span> {i: [] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_buckets)}</span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>    bucket_midpoints <span class="op">=</span> []</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 1. Bootstrap the entire process</span></span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n_bootstrap):</span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Resample the entire dataframe with replacement</span></span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a>        df_resample <span class="op">=</span> df.sample(frac<span class="op">=</span><span class="dv">1</span>, replace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Bin the continuous column using qcut on the resampled data</span></span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true" tabindex="-1"></a>            df_resample[<span class="st">&#39;bucket&#39;</span>], bins <span class="op">=</span> pd.qcut(df_resample[continuous_col], q<span class="op">=</span>n_buckets, duplicates<span class="op">=</span><span class="st">&#39;drop&#39;</span>, retbins<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Calculate the midpoints of the bins (to use on the x-axis)</span></span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true" tabindex="-1"></a>            bucket_midpoints <span class="op">=</span> [(bins[i] <span class="op">+</span> bins[i<span class="op">+</span><span class="dv">1</span>]) <span class="op">/</span> <span class="dv">2</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(bins) <span class="op">-</span> <span class="dv">1</span>)]</span>
<span id="cb12-34"><a href="#cb12-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-35"><a href="#cb12-35" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Calculate the mean for each bucket in this bootstrap sample</span></span>
<span id="cb12-36"><a href="#cb12-36" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> i, bucket <span class="kw">in</span> <span class="bu">enumerate</span>(df_resample[<span class="st">&#39;bucket&#39;</span>].unique().sort_values()):</span>
<span id="cb12-37"><a href="#cb12-37" aria-hidden="true" tabindex="-1"></a>                bucket_data <span class="op">=</span> df_resample[df_resample[<span class="st">&#39;bucket&#39;</span>] <span class="op">==</span> bucket]</span>
<span id="cb12-38"><a href="#cb12-38" aria-hidden="true" tabindex="-1"></a>                mean_target <span class="op">=</span> bucket_data[target_col].mean()</span>
<span id="cb12-39"><a href="#cb12-39" aria-hidden="true" tabindex="-1"></a>                bootstrap_means[i].append(mean_target)</span>
<span id="cb12-40"><a href="#cb12-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-41"><a href="#cb12-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> <span class="pp">ValueError</span>:</span>
<span id="cb12-42"><a href="#cb12-42" aria-hidden="true" tabindex="-1"></a>            <span class="co"># If there&#39;s a problem with qcut (e.g., not enough unique values for the number of buckets), skip this sample</span></span>
<span id="cb12-43"><a href="#cb12-43" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb12-44"><a href="#cb12-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-45"><a href="#cb12-45" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 2. Compute the mean, 5th, and 95th percentiles for each bucket</span></span>
<span id="cb12-46"><a href="#cb12-46" aria-hidden="true" tabindex="-1"></a>    mean_values <span class="op">=</span> []</span>
<span id="cb12-47"><a href="#cb12-47" aria-hidden="true" tabindex="-1"></a>    lower_percentiles <span class="op">=</span> []</span>
<span id="cb12-48"><a href="#cb12-48" aria-hidden="true" tabindex="-1"></a>    upper_percentiles <span class="op">=</span> []</span>
<span id="cb12-49"><a href="#cb12-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-50"><a href="#cb12-50" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_buckets):</span>
<span id="cb12-51"><a href="#cb12-51" aria-hidden="true" tabindex="-1"></a>        means <span class="op">=</span> bootstrap_means[i]</span>
<span id="cb12-52"><a href="#cb12-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-53"><a href="#cb12-53" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Mean of the bootstrapped means</span></span>
<span id="cb12-54"><a href="#cb12-54" aria-hidden="true" tabindex="-1"></a>        mean_values.append(np.mean(means))</span>
<span id="cb12-55"><a href="#cb12-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-56"><a href="#cb12-56" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 5th and 95th percentiles</span></span>
<span id="cb12-57"><a href="#cb12-57" aria-hidden="true" tabindex="-1"></a>        lower_percentiles.append(np.percentile(means, <span class="dv">5</span>))</span>
<span id="cb12-58"><a href="#cb12-58" aria-hidden="true" tabindex="-1"></a>        upper_percentiles.append(np.percentile(means, <span class="dv">95</span>))</span>
<span id="cb12-59"><a href="#cb12-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-60"><a href="#cb12-60" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 3. Plot each bootstrap sample in light gray (if desired)</span></span>
<span id="cb12-61"><a href="#cb12-61" aria-hidden="true" tabindex="-1"></a>    plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb12-62"><a href="#cb12-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-63"><a href="#cb12-63" aria-hidden="true" tabindex="-1"></a>    valid_bootstrap_samples <span class="op">=</span> <span class="bu">min</span>([<span class="bu">len</span>(bootstrap_means[i]) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_buckets)])</span>
<span id="cb12-64"><a href="#cb12-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-65"><a href="#cb12-65" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> valid_bootstrap_samples <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb12-66"><a href="#cb12-66" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(valid_bootstrap_samples):</span>
<span id="cb12-67"><a href="#cb12-67" aria-hidden="true" tabindex="-1"></a>            means <span class="op">=</span> [bootstrap_means[j][i] <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n_buckets)]</span>
<span id="cb12-68"><a href="#cb12-68" aria-hidden="true" tabindex="-1"></a>            plt.plot(bucket_midpoints, means, color<span class="op">=</span><span class="st">&#39;lightgray&#39;</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb12-69"><a href="#cb12-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-70"><a href="#cb12-70" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 4. Plot the shaded area for the 5th and 95th percentiles</span></span>
<span id="cb12-71"><a href="#cb12-71" aria-hidden="true" tabindex="-1"></a>        plt.fill_between(bucket_midpoints, lower_percentiles, upper_percentiles, color<span class="op">=</span><span class="st">&#39;gray&#39;</span>, alpha<span class="op">=</span><span class="fl">0.3</span>, label<span class="op">=</span><span class="st">&#39;5th-95th Percentiles&#39;</span>)</span>
<span id="cb12-72"><a href="#cb12-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-73"><a href="#cb12-73" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 5. Overlay the mean across all bootstrap samples for each bucket in blue</span></span>
<span id="cb12-74"><a href="#cb12-74" aria-hidden="true" tabindex="-1"></a>        plt.plot(bucket_midpoints, mean_values, color<span class="op">=</span><span class="st">&#39;blue&#39;</span>, marker<span class="op">=</span><span class="st">&#39;o&#39;</span>, label<span class="op">=</span><span class="st">&#39;Mean of Bootstraps&#39;</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb12-75"><a href="#cb12-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-76"><a href="#cb12-76" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Add labels and title</span></span>
<span id="cb12-77"><a href="#cb12-77" aria-hidden="true" tabindex="-1"></a>        plt.xlabel(<span class="ss">f&quot;</span><span class="sc">{</span>continuous_col<span class="sc">}</span><span class="ss"> (Original Scale)&quot;</span>)</span>
<span id="cb12-78"><a href="#cb12-78" aria-hidden="true" tabindex="-1"></a>        plt.ylabel(<span class="ss">f&quot;Mean of </span><span class="sc">{</span>target_col<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb12-79"><a href="#cb12-79" aria-hidden="true" tabindex="-1"></a>        plt.title(<span class="ss">f&quot;Bootstrapped Mean of </span><span class="sc">{</span>target_col<span class="sc">}</span><span class="ss"> by </span><span class="sc">{</span>continuous_col<span class="sc">}</span><span class="ss"> Buckets&quot;</span>)</span>
<span id="cb12-80"><a href="#cb12-80" aria-hidden="true" tabindex="-1"></a>        plt.grid(<span class="va">True</span>)</span>
<span id="cb12-81"><a href="#cb12-81" aria-hidden="true" tabindex="-1"></a>        plt.legend()</span>
<span id="cb12-82"><a href="#cb12-82" aria-hidden="true" tabindex="-1"></a>        plt.show()</span>
<span id="cb12-83"><a href="#cb12-83" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb12-84"><a href="#cb12-84" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">&quot;Not enough valid bootstrap samples to plot.&quot;</span>)</span></code></pre></div>
    
</body>
</html>